// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// © LuxAlgo
 
//@version=5

indicator("Support and Resistance Signals MTF [LuxAlgo]", 'fake MTF', true, max_boxes_count = 500, max_lines_count = 500, max_labels_count = 500)

//------------------------------------------------------------------------------
// Settings
//-----------------------------------------------------------------------------{

srGR   = 'Support & Resistance Settings'
srTT   = 'tip : in ranging markets higher timeframe resolution or higher detection length might help reduce the noise'
srTF   = input.string('Chart', 'Detection Timeframe', options=['Chart', '15 Minutes', '1 Hour', '4 Hours', '1 Day', '1 Week'], group = srGR, tooltip = srTT)
srLN   = input(15, 'Detection Length', group = srGR)

srMR   = input.float(2, 'Support Resistance Margin', minval = .1, maxval = 10, step = .1, group = srGR)

srSLC  = input(color.new(#089981, 53), '   - Support,     Lines', inline = 'srS', group = srGR)
srSZC  = input(color.new(#089981, 83), 'Zones', inline = 'srS', group = srGR)
srRLC  = input(color.new(#f23645, 53), '   - Resistance, Lines', inline = 'srR', group = srGR)
srRZC  = input(color.new(#f23645, 83), 'Zones', inline = 'srR', group = srGR)

srHST  = input.bool(true, 'Check Previous Historical S&R Zone', group = srGR)

mnGR   = 'Manupulations' 
mnSH   = input.bool(true, 'Manupulation Zones', group = mnGR)
mnMR   = input.float(1.3, 'Manupulation Margin', minval = .1, maxval = 10, step = .1, group = mnGR)
mnSZC  = input(color.new(#2962ff, 73), 'Manupulation Zones, Support', inline = 'LQ', group = mnGR)
mnRZC  = input(color.new(#ff9800, 73), 'Resistance', inline = 'LQ', group = mnGR)

sigGR  = 'Signals'
srFBT  = 'Filters the breakouts that failed to continue beyond a level'
srFBO  = input.bool(true, 'Avoid False Breakouts', group = sigGR, tooltip = srFBT)

srBUC  = input(color.new(#089981, 33), 'Breakouts, Bullish', inline = 'srB', group = sigGR)
srBDC  = input(color.new(#f23645, 33), 'Bearish', inline = 'srB', group = sigGR)
srBS   = input.string('Tiny', "", options=['Auto', 'Tiny', 'Small', 'Normal', 'None'], inline = 'srB', group = sigGR)

srTUC  = input(color.new(#2962ff, 33), 'Tests,        Bullish', inline = 'srT', group = sigGR)
srTDC  = input(color.new(#e040fb, 33), 'Bearish', inline = 'srT', group = sigGR)
srTS   = input.string('Tiny', "", options=['Auto', 'Tiny', 'Small', 'Normal', 'None'], inline = 'srT', group = sigGR)

srRUC  = input(color.new(#089981, 33), 'Retests,     Bullish', inline = 'srR', group = sigGR)
srRDC  = input(color.new(#f23645, 33), 'Bearish', inline = 'srR', group = sigGR)
srRS   = input.string('Tiny', "", options=['Auto', 'Tiny', 'Small', 'Normal', 'None'], inline = 'srR', group = sigGR)

srPUC  = input(color.new(#089981, 33), 'Rejections, Bullish', inline = 'srP', group = sigGR)
srPDC  = input(color.new(#f23645, 33), 'Bearish', inline = 'srP', group = sigGR)
srPS   = input.string('Tiny', "", options=['Auto', 'Tiny', 'Small', 'Normal', 'None'], inline = 'srP', group = sigGR)

othGR  = 'Others'
swSH   = input.string('None', "Swing Levels", options=['Auto', 'Small', 'Normal', 'Large', 'None'], inline = 'sw', group = othGR)
swHC   = input(color.new(#f23645, 33), 'H', inline = 'sw', group = othGR)
swLC   = input(color.new(#089981, 33), 'L', inline = 'sw', group = othGR)

//-----------------------------------------------------------------------------}
// User Defined Types
//-----------------------------------------------------------------------------{

// @type        bar properties with their values 
//
// @field o     (float) open price of the bar
// @field h     (float) high price of the bar
// @field l     (float) low price of the bar
// @field c     (float) close price of the bar
// @field v     (float) volume of the bar
// @field i     (int) index of the bar

type bar
    float o = open
    float h = high
    float l = low
    float c = close
    float v = volume
    int   i = bar_index

// @type        store pivot high/low and index data 
//
// @field cur_idx     (int)    last pivot bar index
// @field pre_idx    (int)    previous pivot bar index
// @field cur_ph     (float)  last pivot high
// @field pre_ph    (float)  previous pivot high
// @field cur_pl     (float)  last pivot low
// @field pre_pl    (float)  previous pivot low
// @field is_cross_ph    (bool)   pivot high cross status
// @field is_cross_pl    (bool)   pivot low cross status

type pivotPoint
    int    cur_idx
    int    pre_idx
    float  cur_ph
    float  pre_ph
    float  cur_pl
    float  pre_pl
    bool   is_cross_ph
    bool   is_cross_pl

// @type        stores support and resistance visuals and signal status 
//
// @field bx_snr_zone    (box)   support and resistance zones
// @field bx_liquidity_sweeps    (box)   liquidity sweeps
// @field ln    (line)  support and resistance levels
// @field breakout_status     (bool)  breakout status
// @field test_status     (bool)  test status
// @field retest_status     (bool)  retest status
// @field liqudation_status     (bool)  liqudation status
// @field default_margin     (float) default margin 

type SnR
    box    bx_snr_zone
    box    bx_liquidity_sweeps
    line   ln
    bool   breakout_status
    bool   test_status
    bool   retest_status
    bool   liqudation_status
    float  default_margin

//-----------------------------------------------------------------------------}
// Variables
//-----------------------------------------------------------------------------{

bar b = bar.new()

var pivotPoint pp  = pivotPoint.new()

var SnR[] R = array.new<SnR> (1, SnR.new(box(na), box(na), line(na), false, false, false, false, na))  
var SnR[] S = array.new<SnR> (1, SnR.new(box(na), box(na), line(na), false, false, false, false, na)) 

var SnR lR  = SnR.new(box(na), box(na), line(na), false, false, false, false, na)
var SnR lS  = SnR.new(box(na), box(na), line(na), false, false, false, false, na)
var SnR lRt = SnR.new(box(na), box(na), line(na), false, false, false, false, na)
var SnR lSt = SnR.new(box(na), box(na), line(na), false, false, false, false, na)

var int mss = 0

//-----------------------------------------------------------------------------}
// General Calculations
//-----------------------------------------------------------------------------{

int tf_m = switch srTF
    "Chart"      => timeframe.isintraday ? timeframe.multiplier : timeframe.isdaily ? 1440 : timeframe.isweekly ? 10080 : 10080 * 30
    "15 Minutes" => 15
    "1 Hour"     => 60
    "4 Hours"    => 240
    "1 Day"      => 1440
    "1 Week"     => 10080

ch_m  = if timeframe.isintraday
    timeframe.multiplier
else if timeframe.isdaily
    1440
else if timeframe.isweekly
    10080
else if timeframe.ismonthly
    10080 * 30

srLN := srLN * tf_m / ch_m

    

pHST = ta.highest(b.h, srLN)
pLST = ta.lowest (b.l, srLN)

atr   = ta.atr(17)
isLLS = math.abs(b.l - math.min(b.o, b.c)) >= 1.618 * atr
isLUS = math.abs(b.h - math.max(b.o, b.c)) >= 1.618 * atr

vSMA  = ta.sma(nz(b.v), 17)
isHV  = nz(b.v) >= 1.618 * vSMA
isLV  = nz(b.v) <= 0.618 * vSMA
vST   = isHV ? '\n *High Trading Activity' : isLV ? '\n *Low Trading Activity' : '\n *Average Trading Activity'

if nz(b.v) > vSMA * 4.669
    alert('High trading activity (Volume SPIKE) detected\n' + syminfo.ticker + ' price (' + str.tostring(b.c, format.mintick) + '), timeframe ' + timeframe.period)

srBUC := srBS != 'None' ? srBUC : color(na)
srBDC := srBS != 'None' ? srBDC : color(na)
srBTC  = srBS != 'None' ? color.white : color(na)

srTUC := srTS != 'None' ? srTUC : color(na)
srTDC := srTS != 'None' ? srTDC : color(na)
srTTC  = srTS != 'None' ? color.white : color(na)

srRUC := srRS != 'None' ? srRUC : color(na)
srRDC := srRS != 'None' ? srRDC : color(na)
srRTC  = srRS != 'None' ? color.white : color(na)

//-----------------------------------------------------------------------------}
// Functions/Methods
//-----------------------------------------------------------------------------{

// @function        calcuates cumulative volume of the given range
//                     
// @param _l        (int)  length of the range
// @param _o        (int)  offset 
//
// @returns         (float) cumulative volume

f_getTradedVolume(_l, _o) =>
    v = 0.
    for x = 0 to _l - 1
        v += volume[_o + x]
    v

// @function        converts size strings to enumerated values
//                     
// @param _l        (string) size string
//
// @returns         (enumeration) size enumerated value

f_getSize(_s) =>
    switch _s
        'Tiny'   => size.tiny
        'Small'  => size.small
        'Normal' => size.normal
        'Large'  => size.large
        'Huge'   => size.huge
        => size.auto

//-----------------------------------------------------------------------------}
// Calculations
//-----------------------------------------------------------------------------{

pp_h  = ta.pivothigh(srLN, srLN)

// if barstate.isconfirmed and not na(pp_h)
//     log.info(str.tostring(pp_h))
// bgcolor(not na(pp_h) ? color.green : na,  offset = -srLN)

plot(not na(pp_h) ? high[srLN] : na, "pivot high", color = color.red, linewidth = 4, style = plot.style_circles, offset = -srLN)
if not na(pp_h)

    pp.pre_ph  := pp.cur_ph 
    pp.cur_ph   := pp_h
    pp.pre_idx  := pp.cur_idx
    pp.cur_idx   := b.i[srLN]
    pp.is_cross_ph  := false

    if R.size() > 1
        lR  := R.get(0)
        lRt := R.get(1)

        if pp.cur_ph < lR.bx_snr_zone.get_bottom() * (1 - lR.default_margin * .17 * srMR) or pp.cur_ph > lR.bx_snr_zone.get_top() * (1 + lR.default_margin * .17 * srMR) 
            if pp.cur_idx < lR.bx_snr_zone.get_left() and pp.cur_idx + srLN > lR.bx_snr_zone.get_left() and b.c < lR.bx_snr_zone.get_bottom()
                na
            else
                if pp.cur_ph < lRt.bx_snr_zone.get_bottom() * (1 - lRt.default_margin * .17 * srMR) or pp.cur_ph > lRt.bx_snr_zone.get_top() * (1 + lRt.default_margin * .17 * srMR)

                    R.unshift(
                      SnR.new(
                         box.new(pp.cur_idx, pp.cur_ph, b.i, pp.cur_ph * (1 - ((pHST - pLST) / pHST) * .17 * srMR), border_color = color(na), bgcolor = srRZC),
                         box.new(na, na, na, na, bgcolor = color(na), border_color = color(na)),
                         line.new(pp.cur_idx, pp.cur_ph, b.i, pp.cur_ph, color = srRLC, width = srMR <= .5 ? 2 : 3),
                         false, false, false, false, (pHST - pLST) / pHST))

                    lS.test_status := false
                else
                    lRt.bx_snr_zone.set_right(b.i)
                    lRt.ln.set_x2(b.i)

        else if lR.bx_snr_zone.get_top() != lS.bx_snr_zone.get_top()
            lR.bx_snr_zone.set_right(b.i)
            lR.ln.set_x2(b.i)
    else
        R.unshift(
          SnR.new(
             box.new(pp.cur_idx, pp.cur_ph, b.i, pp.cur_ph * (1 - ((pHST - pLST) / pHST) * .17 * srMR), border_color = color(na), bgcolor = srRZC),
             //box.new(pp.cur_idx, pp.cur_ph, b.i, pp.cur_ph * (1 - ((pHST - pLST) / pHST) * .17 * srMR), border_color = color(na), bgcolor = color.new(color.orange, 89)),
             box.new(na, na, na, na, bgcolor = color(na), border_color = color(na)),
             line.new(pp.cur_idx, pp.cur_ph, b.i, pp.cur_ph, color = srRLC, width = srMR <= .5 ? 2 : 3),
             false, false, false, false, (pHST - pLST) / pHST))

        lS.test_status := false

    if swSH != 'None'
        StS = pp.cur_idx - pp.pre_idx
        tradedVolume = f_getTradedVolume(StS, srLN)
        swH = pp.cur_ph > pp.pre_ph ? "Higher High" : pp.cur_ph < pp.pre_ph ? "Lower High" : na
        rTT = 'Swing High (' + swH + ') : ' + str.tostring(pp.cur_ph, format.mintick) + 
              (mss == -1 and pp.cur_ph < pp.pre_ph ? '\n    *Counter-Trend Move' : '') +
              '\n -Price Change : ↑ %' + str.tostring((pp.cur_ph - pp.cur_pl) * 100 / pp.cur_pl , '#.##') + 
              (nz(b.v) ? '\n -Traded Volume : ' + str.tostring(tradedVolume, format.volume)  + ' (' + str.tostring(StS - 1) + ' bars)' +
              '\n    *Average Volume/Bar : ' + str.tostring(tradedVolume / (StS - 1), format.volume) : '') 
        label.new(pp.cur_idx, pp.cur_ph, '◈', color = color(na), style = label.style_label_down, textcolor = swHC, size = f_getSize(swSH), tooltip = rTT)

        alert('New ' + swH + (mss == -1 and pp.cur_ph < pp.pre_ph ? ' (counter-trend move)' : '') + ' formed\n' + syminfo.ticker + ' price (' + str.tostring(b.c, format.mintick) + '), timeframe ' + timeframe.period)

if b.c[1] > pp.cur_ph and b.c > pp.cur_ph and not pp.is_cross_ph 
    pp.is_cross_ph := true
    mss := 1

pp_l  = ta.pivotlow (srLN, srLN)
// if barstate.isconfirmed and not na(pp_l)
//     log.info(str.tostring(pp_l))
// bgcolor(not na(pp_l) ? color.red : na, offset = -srLN)
plot(not na(pp_l) ? low[srLN] : na, "pivot low", color = color.green, linewidth = 4, style = plot.style_circles, offset = -srLN)
if not na(pp_l) 
    pp.pre_pl  := pp.cur_pl
    pp.cur_pl   := pp_l
    pp.pre_idx  := pp.cur_idx
    pp.cur_idx   := b.i[srLN]
    pp.is_cross_ph  := false

    if S.size() > 2 
        lS  := S.get(0)
        lSt := S.get(1)

        if pp.cur_pl < lS.bx_snr_zone.get_bottom() * (1 - lS.default_margin * .17 * srMR) or pp.cur_pl > lS.bx_snr_zone.get_top() * (1 + lS.default_margin * .17 * srMR)
            if pp.cur_idx < lS.bx_snr_zone.get_left() and pp.cur_idx + srLN > lS.bx_snr_zone.get_left() and b.c > lS.bx_snr_zone.get_top() //not lR.b
                na
            else
                if pp.cur_pl < lSt.bx_snr_zone.get_bottom() * (1 - lSt.default_margin * .17 * srMR) or pp.cur_pl > lSt.bx_snr_zone.get_top() * (1 + lSt.default_margin * .17 * srMR)

                    S.unshift(
                      SnR.new(
                         box.new(pp.cur_idx, pp.cur_pl * (1 + ((pHST - pLST) / pHST) * .17 * srMR), b.i, pp.cur_pl, border_color = color(na), bgcolor = srSZC),
                         box.new(na, na, na, na, bgcolor = color(na), border_color = color(na)),
                         line.new(pp.cur_idx, pp.cur_pl, b.i, pp.cur_pl, color = srSLC, width = srMR <= .5 ? 2 : 3),
                         false, false, false, false, (pHST - pLST) / pHST))

                    lR.test_status := false
                else
                    lSt.bx_snr_zone.set_right(b.i)
                    lSt.ln.set_x2(b.i)

        else if lS.bx_snr_zone.get_bottom() != lR.bx_snr_zone.get_bottom()
            lS.bx_snr_zone.set_right(b.i)
            lS.ln.set_x2(b.i)
    else
        S.unshift(
          SnR.new(
             box.new(pp.cur_idx, pp.cur_pl * (1 + ((pHST - pLST) / pHST) * .17 * srMR), b.i, pp.cur_pl, border_color = color(na), bgcolor = srSZC),
             //box.new(pp.cur_idx, pp.cur_pl * (1 + ((pHST - pLST) / pHST) * .17 * srMR), b.i, pp.cur_pl, border_color = color(na), bgcolor = color.new(color.aqua, 89)),
             box.new(na, na, na, na, bgcolor = color(na), border_color = color(na)),
             line.new(pp.cur_idx, pp.cur_pl, b.i, pp.cur_pl, color = srSLC, width = srMR <= .5 ? 2 : 3),
             false, false, false, false, (pHST - pLST) / pHST))

        lR.test_status := false

    if swSH != 'None'
        StS = pp.cur_idx - pp.pre_idx
        tradedVolume = f_getTradedVolume(StS, srLN)
        swL = pp.cur_pl < pp.pre_pl ? "Lower Low" : pp.cur_pl > pp.pre_pl ? "Higher Low" : na
        sTT = 'Swing Low (' + swL + ') : ' + str.tostring(pp.cur_pl, format.mintick) + 
              (mss == 1 and pp.cur_pl > pp.pre_pl ? '\n    *Counter-Trend Move' : '') +
              '\n -Price Change : ↓ %' + str.tostring((pp.cur_ph - pp.cur_pl) * 100 / pp.cur_ph , '#.##') + 
              (nz(b.v) ? '\n -Traded Volume : ' + str.tostring(tradedVolume, format.volume)  + ' (' + str.tostring(StS - 1) + ' bars)' +
              '\n    *Average Volume/Bar : ' + str.tostring(tradedVolume / (StS - 1), format.volume) : '')
        label.new(pp.cur_idx, pp.cur_pl, '◈', color = color(na), style = label.style_label_up, textcolor = swLC, size = f_getSize(swSH), tooltip = sTT)

        alert('New ' + swL + (mss == 1 and pp.cur_pl > pp.pre_pl ? ' (counter-trend move)' : '') + ' formed\n' + syminfo.ticker + ' price (' + str.tostring(b.c, format.mintick) + '), timeframe ' + timeframe.period)

if b.c[1] < pp.cur_pl and b.c < pp.cur_pl and not pp.is_cross_pl 
    pp.is_cross_pl := true
    mss := -1

if R.size() > 0
    lR := R.get(0)

    if  srFBO and b.c[1] > lR.bx_snr_zone.get_top() * (1 + lR.default_margin * .17) and not lR.breakout_status
        lR.bx_snr_zone.set_right(b.i[1])
        lR.ln.set_x2(b.i[1])
        lR.breakout_status := true
        lR.retest_status := false

        label.new(b.i[1], b.l[1] * (1 - lR.default_margin * .017), '▲\n\nB', color = srBUC, style = label.style_label_up , textcolor = srBTC, size = f_getSize(srBS), tooltip = 'Bullish Breakout' + vST[1])
        //label.new(b.i[1], b.l[1] * (1 - lR.default_margin * .017), '▲\n\nB', color = color.yellow, style = label.style_label_up , textcolor = srBTC, size = f_getSize(srBS), tooltip = 'Bullish Breakout' + vST[1])

        S.unshift(
          SnR.new(
             box.new(b.i[1], lR.bx_snr_zone.get_top(), b.i + 1, lR.bx_snr_zone.get_bottom(), border_color = color(na), bgcolor = srSZC),
             box.new(na, na, na, na, bgcolor = color(na), border_color = color(na)),
             line.new(b.i[1], lR.bx_snr_zone.get_bottom(), b.i + 1, lR.bx_snr_zone.get_bottom(), color = srSLC, width = srMR <= .5 ? 2 : 3),
             false, false, false, false, lR.default_margin))
        //R.remove(0)

        if srBS != 'None'
            alert('Bullish breakout detected\n' + syminfo.ticker + ' price (' + str.tostring(b.c, format.mintick) + '), timeframe ' + timeframe.period)

    else if b.c[1] > lR.bx_snr_zone.get_top() and not lR.breakout_status and not srFBO
        lR.bx_snr_zone.set_right(b.i[1])
        lR.ln.set_x2(b.i[1])
        lR.breakout_status := true
        lR.retest_status := false

        label.new(b.i[1], b.l[1] * (1 - lR.default_margin * .017), '▲\n\nB', color = srBUC, style = label.style_label_up , textcolor = srBTC, size = f_getSize(srBS), tooltip = 'Bullish Breakout' + vST[1])

        S.unshift(
          SnR.new(
             box.new(b.i[1], lR.bx_snr_zone.get_top(), b.i + 1, lR.bx_snr_zone.get_bottom(), border_color = color(na), bgcolor = srSZC),
             box.new(na, na, na, na, bgcolor = color(na), border_color = color(na)),
             line.new(b.i[1], lR.bx_snr_zone.get_bottom(), b.i + 1, lR.bx_snr_zone.get_bottom(), color = srSLC, width = srMR <= .5 ? 2 : 3),
             false, false, false, false, lR.default_margin))
        //R.remove(0)

        if srBS != 'None'
            alert('Bullish breakout detected\n' + syminfo.ticker + ' price (' + str.tostring(b.c, format.mintick) + '), timeframe ' + timeframe.period)

    else if lS.breakout_status and b.o[1] < lR.bx_snr_zone.get_top() and b.h[1] > lR.bx_snr_zone.get_bottom() and b.c[1] < lR.bx_snr_zone.get_bottom() and not lR.retest_status and b.i[1] != lR.bx_snr_zone.get_left()
        label.new(b.i[1], b.h[1] * (1 + lR.default_margin * .017), 'R', color = srRDC, style = label.style_label_down , textcolor = srRTC, size = f_getSize(srRS), tooltip = 'Re-test of Resistance Zone' + vST[1] )
        lR.retest_status := true //
        lR.bx_snr_zone.set_right(b.i)
        lR.ln.set_x2(b.i)

        if srRS != 'None'
            alert('Re-test of resistance zone detected\n' + syminfo.ticker + ' price (' + str.tostring(b.c, format.mintick) + '), timeframe ' + timeframe.period)

    else if b.h[1] > lR.bx_snr_zone.get_bottom() and b.c[1] < lR.bx_snr_zone.get_top() and b.c < lR.bx_snr_zone.get_top() and not lR.test_status and not lR.retest_status and not lR.breakout_status and not lS.breakout_status and b.i[1] != lR.bx_snr_zone.get_left()
        label.new(b.i[1], b.h[1] * (1 + lR.default_margin * .017), 'T', color = srTDC, style = label.style_label_down , textcolor = srTTC, size = f_getSize(srTS), tooltip = 'Test of Resistance Zone' + vST[1] )
        lR.test_status := true
        lR.bx_snr_zone.set_right(b.i)
        lR.ln.set_x2(b.i)

        if srTS != 'None'
            alert('Test of resistance zone detected\n' + syminfo.ticker + ' price (' + str.tostring(b.c, format.mintick) + '), timeframe ' + timeframe.period, alert.freq_once_per_bar_close)

    else if b.h > lR.bx_snr_zone.get_bottom() * (1 - lR.default_margin * .17) and not lR.breakout_status //and lR.bx_snr_zone.get_top() != lS.bx_snr_zone.get_top()
        if b.h > lR.bx_snr_zone.get_bottom()
            lR.bx_snr_zone.set_right(b.i)
        lR.ln.set_x2(b.i)

    if isLLS[1] and isHV[1] and srPS != 'None'
        label.new(b.i[1], b.l[1] * (1 - lR.default_margin * .017), '', color = srPUC, style = label.style_label_up , textcolor = color.white, size = f_getSize(srPS), tooltip = 'Rejection of Lower Prices' + vST[1])
        alert('Rejection of lower prices detected\n' + syminfo.ticker + ' price (' + str.tostring(b.c, format.mintick) + '), timeframe ' + timeframe.period)

    if mnSH
        if b.h > lR.bx_snr_zone.get_top() and b.c <= lR.bx_snr_zone.get_top() * (1 + lR.default_margin * .17 * mnMR) and not lR.liqudation_status and b.i == lR.bx_snr_zone.get_right()
            if lR.bx_liquidity_sweeps.get_right() + srLN > b.i
                lR.bx_liquidity_sweeps.set_right(b.i + 1)
                lR.bx_liquidity_sweeps.set_top(math.min(math.max(b.h, lR.bx_liquidity_sweeps.get_top()), lR.bx_snr_zone.get_top() * (1 + lR.default_margin * .17 * mnMR)))
            else
                lR.bx_liquidity_sweeps.set_lefttop(b.i[1], math.min(b.h, lR.bx_snr_zone.get_top() * (1 + lR.default_margin * .17 * mnMR)))
                lR.bx_liquidity_sweeps.set_rightbottom(b.i + 1, lR.bx_snr_zone.get_top())
                lR.bx_liquidity_sweeps.set_bgcolor(mnRZC)

            lR.liqudation_status := true

        else if b.h > lR.bx_snr_zone.get_top() and b.c <= lR.bx_snr_zone.get_top() * (1 + lR.default_margin * .17 * mnMR) and lR.liqudation_status and b.i == lR.bx_snr_zone.get_right()
            lR.bx_liquidity_sweeps.set_right(b.i + 1)
            lR.bx_liquidity_sweeps.set_top(math.min(math.max(b.h,lR.bx_liquidity_sweeps.get_top()), lR.bx_snr_zone.get_top() * (1 + lR.default_margin * .17 * mnMR)))
        else if lR.liqudation_status and (b.c >= lR.bx_snr_zone.get_top() * (1 + lR.default_margin * .17 * mnMR) or b.c < lR.bx_snr_zone.get_bottom())
            lR.liqudation_status := false

if R.size() > 1 and srHST //and (lR.b or lS.b)// and lR.bx_snr_zone.get_top() != lS.bx_snr_zone.get_top()
    lRt := R.get(1)

    if lR.bx_snr_zone.get_top() != lRt.bx_snr_zone.get_top()

        if  srFBO and b.c[1] > lRt.bx_snr_zone.get_top() * (1 + lRt.default_margin * .17) and not lRt.breakout_status
            lRt.bx_snr_zone.set_right(b.i[1])
            lRt.ln.set_x2(b.i[1])
            lRt.breakout_status := true
            lRt.retest_status  := false

            label.new(b.i[1], b.l[1] * (1 - lRt.default_margin * .017), '▲\n\nB', color = srBUC, style = label.style_label_up , textcolor = srBTC, size = f_getSize(srBS), tooltip = 'Bullish Breakout' + vST[1])

            S.unshift(
              SnR.new(
                 box.new(b.i[1], lRt.bx_snr_zone.get_top(), b.i + 1, lRt.bx_snr_zone.get_bottom(), border_color = color(na), bgcolor = srSZC),
                 box.new(na, na, na, na, bgcolor = color(na), border_color = color(na)),
                 line.new(b.i[1], lRt.bx_snr_zone.get_bottom(), b.i + 1, lRt.bx_snr_zone.get_bottom(), color = srSLC, width = srMR <= .5 ? 2 : 3),
                 false, false, false, false, lRt.default_margin))
            //R.remove(1)

            if srBS != 'None'
                alert('Bullish breakout detected\n' + syminfo.ticker + ' price (' + str.tostring(b.c, format.mintick) + '), timeframe ' + timeframe.period)

        else if b.c[1] > lRt.bx_snr_zone.get_top() and not lRt.breakout_status and not srFBO
            lRt.bx_snr_zone.set_right(b.i[1])
            lRt.ln.set_x2(b.i[1])
            lRt.breakout_status := true
            lRt.retest_status  := false

            label.new(b.i[1], b.l[1] * (1 - lRt.default_margin * .017), '▲\n\nB', color = srBUC, style = label.style_label_up , textcolor = srBTC, size = f_getSize(srBS), tooltip = 'Bullish Breakout' + vST[1])

            S.unshift(
              SnR.new(
                 box.new(b.i[1], lRt.bx_snr_zone.get_top(), b.i + 1, lRt.bx_snr_zone.get_bottom(), border_color = color(na), bgcolor = srSZC),
                 box.new(na, na, na, na, bgcolor = color(na), border_color = color(na)),
                 line.new(b.i[1], lRt.bx_snr_zone.get_bottom(), b.i + 1, lRt.bx_snr_zone.get_bottom(), color = srSLC, width = srMR <= .5 ? 2 : 3),
                 false, false, false, false, lRt.default_margin))
            //R.remove(1)

            if srBS != 'None'
                alert('Bullish breakout detected\n' + syminfo.ticker + ' price (' + str.tostring(b.c, format.mintick) + '), timeframe ' + timeframe.period)

        else if lSt.breakout_status and b.o[1] < lRt.bx_snr_zone.get_top() and b.h[1] > lRt.bx_snr_zone.get_bottom() and b.c[1] < lRt.bx_snr_zone.get_bottom() and not lRt.retest_status  and b.i[1] != lRt.bx_snr_zone.get_left()
            label.new(b.i[1], b.h[1] * (1 + lRt.default_margin * .017), 'R', color = srRDC, style = label.style_label_down , textcolor = srRTC, size = f_getSize(srRS), tooltip = 'Re-test of Resistance Zone' + vST[1] )
            lRt.retest_status  := true //
            lRt.bx_snr_zone.set_right(b.i)
            lRt.ln.set_x2(b.i)

            if srRS != 'None'
                alert('Re-test of resistance zone detected\n' + syminfo.ticker + ' price (' + str.tostring(b.c, format.mintick) + '), timeframe ' + timeframe.period)

        else if b.h[1] > lRt.bx_snr_zone.get_bottom() and b.c[1] < lRt.bx_snr_zone.get_top() and b.c < lRt.bx_snr_zone.get_top() and not lSt.test_status and not lRt.breakout_status and not lSt.breakout_status and b.i[1] != lRt.bx_snr_zone.get_left()
            label.new(b.i[1], b.h[1] * (1 + lRt.default_margin * .017), 'T', color = srTDC, style = label.style_label_down , textcolor = srTTC, size = f_getSize(srTS), tooltip = 'Test of Resistance Zone' + vST[1] )
            lSt.test_status := true
            lRt.bx_snr_zone.set_right(b.i)
            lRt.ln.set_x2(b.i)

            if srTS != 'None'
                alert('Test of resistance zone detected\n' + syminfo.ticker + ' price (' + str.tostring(b.c, format.mintick) + '), timeframe ' + timeframe.period, alert.freq_once_per_bar_close)

        else if b.h > lRt.bx_snr_zone.get_bottom() * (1 - lRt.default_margin * .17) and not lRt.breakout_status
            if b.h > lRt.bx_snr_zone.get_bottom()
                lRt.bx_snr_zone.set_right(b.i)
            lRt.ln.set_x2(b.i)

        if mnSH
            if b.h > lRt.bx_snr_zone.get_top() and b.c <= lRt.bx_snr_zone.get_top() * (1 + lRt.default_margin * .17 * mnMR) and not lRt.liqudation_status and b.i == lRt.bx_snr_zone.get_right()
                if lRt.bx_liquidity_sweeps.get_right() + srLN > b.i
                    lRt.bx_liquidity_sweeps.set_right(b.i + 1)
                    lRt.bx_liquidity_sweeps.set_top(math.min(math.max(b.h, lRt.bx_liquidity_sweeps.get_top()), lRt.bx_snr_zone.get_top() * (1 + lRt.default_margin * .17 * mnMR)))
                else
                    lRt.bx_liquidity_sweeps.set_lefttop(b.i[1], math.min(b.h, lRt.bx_snr_zone.get_top() * (1 + lRt.default_margin * .17 * mnMR)))
                    lRt.bx_liquidity_sweeps.set_rightbottom(b.i + 1, lRt.bx_snr_zone.get_top())
                    lRt.bx_liquidity_sweeps.set_bgcolor(mnRZC)
    
                lRt.liqudation_status := true
    
            else if b.h > lRt.bx_snr_zone.get_top() and b.c <= lRt.bx_snr_zone.get_top() * (1 + lRt.default_margin * .17 * mnMR) and lRt.liqudation_status and b.i == lRt.bx_snr_zone.get_right()
                lRt.bx_liquidity_sweeps.set_right(b.i + 1)
                lRt.bx_liquidity_sweeps.set_top(math.min(math.max(b.h, lRt.bx_liquidity_sweeps.get_top()), lRt.bx_snr_zone.get_top() * (1 + lRt.default_margin * .17 * mnMR)))
            else if lRt.liqudation_status and (b.c >= lRt.bx_snr_zone.get_top() * (1 + lRt.default_margin * .17 * mnMR) or b.c < lRt.bx_snr_zone.get_bottom())
                lRt.liqudation_status := false

if S.size() > 1
    lS := S.get(0)

    if  srFBO and b.c[1] < lS.bx_snr_zone.get_bottom() * (1 - lS.default_margin * .17) and not lS.breakout_status
        lS.bx_snr_zone.set_right(b.i[1])
        lS.ln.set_x2(b.i[1])
        lS.breakout_status:= true
        lS.retest_status := false

        label.new(b.i[1], b.h[1] * (1 + lS.default_margin * .017), 'B\n\n▼', color = srBDC, style = label.style_label_down , textcolor = srBTC, size = f_getSize(srBS), tooltip = 'Bearish Breakout' + vST[1] )
        //label.new(b.i[1], b.h[1] * (1 + lS.default_margin * .017), 'B\n\n▼', color = color.yellow, style = label.style_label_down , textcolor = srBTC, size = f_getSize(srBS), tooltip = 'Bearish Breakout' + vST[1] )

        R.unshift(
          SnR.new(
             box.new(b.i[1], lS.bx_snr_zone.get_top(), b.i + 1, lS.bx_snr_zone.get_bottom(), border_color = color(na), bgcolor = srRZC),
             box.new(na, na, na, na, bgcolor = color(na), border_color = color(na)),
             line.new(b.i[1], lS.bx_snr_zone.get_top(), b.i + 1, lS.bx_snr_zone.get_top(), color = srRLC, width = srMR <= .5 ? 2 : 3),
             false, false, false, false, lS.default_margin))
        //S.remove(0)

        if srBS != 'None'
            alert('Bearish breakout detected\n' + syminfo.ticker + ' price (' + str.tostring(b.c, format.mintick) + '), timeframe ' + timeframe.period)

    if  b.c[1] < lS.bx_snr_zone.get_bottom() and not lS.breakout_status and not srFBO
        lS.bx_snr_zone.set_right(b.i[1])
        lS.ln.set_x2(b.i[1])
        lS.breakout_status := true
        lS.retest_status := false

        label.new(b.i[1], b.h[1] * (1 + lS.default_margin * .017), 'B\n\n▼', color = srBDC, style = label.style_label_down , textcolor = srBTC, size = f_getSize(srBS), tooltip = 'Bearish Breakout' + vST[1] )

        R.unshift(
          SnR.new(
             box.new(b.i[1], lS.bx_snr_zone.get_top(), b.i + 1, lS.bx_snr_zone.get_bottom(), border_color = color(na), bgcolor = srRZC),
             box.new(na, na, na, na, bgcolor = color(na), border_color = color(na)),
             line.new(b.i[1], lS.bx_snr_zone.get_top(), b.i + 1, lS.bx_snr_zone.get_top(), color = srRLC, width = srMR <= .5 ? 2 : 3),
             false, false, false, false, lS.default_margin ))
        //S.remove(0)

        if srBS != 'None'
            alert('Bearish breakout detected\n' + syminfo.ticker + ' price (' + str.tostring(b.c, format.mintick) + '), timeframe ' + timeframe.period)

    else if lR.breakout_status and b.o[1] > lS.bx_snr_zone.get_bottom() and b.l[1] < lS.bx_snr_zone.get_top() and b.c[1] > lS.bx_snr_zone.get_top() and not lS.retest_status and b.i[1] != lS.bx_snr_zone.get_left()
        label.new(b.i[1], b.l[1] * (1 - lS.default_margin * .017), 'R', color = srRUC, style = label.style_label_up , textcolor = srRTC, size = f_getSize(srRS), tooltip = 'Re-test of Support Zone' + vST[1] )
        lS.retest_status := true //
        lS.bx_snr_zone.set_right(b.i)
        lS.ln.set_x2(b.i)

        if srRS != 'None'
            alert('Re-test of support zone detected\n' + syminfo.ticker + ' price (' + str.tostring(b.c, format.mintick) + '), timeframe ' + timeframe.period)

    else if b.l[1] < lS.bx_snr_zone.get_top() and b.c[1] > lS.bx_snr_zone.get_bottom() and b.c > lS.bx_snr_zone.get_bottom() and not lS.test_status and not lS.breakout_status and not lR.breakout_status and b.i[1] != lS.bx_snr_zone.get_left()
        label.new(b.i[1], b.l[1] * (1 - lS.default_margin * .017), 'T', color = srTUC, style = label.style_label_up , textcolor = srTTC, size = f_getSize(srTS), tooltip = 'Test of Support Zone' + vST[1] )
        lS.test_status := true
        lS.bx_snr_zone.set_right(b.i)
        lS.ln.set_x2(b.i)

        if srTS != 'None'
            alert('Test of support zone detected\n' + syminfo.ticker + ' price (' + str.tostring(b.c, format.mintick) + '), timeframe ' + timeframe.period, alert.freq_once_per_bar_close)

    else if b.l < lS.bx_snr_zone.get_top() * (1 + lS.default_margin * .17) and not lS.breakout_status//and lS.bx_snr_zone.get_bottom() != lR.bx_snr_zone.get_bottom()
        if b.l < lS.bx_snr_zone.get_top()
            lS.bx_snr_zone.set_right(b.i)
        lS.ln.set_x2(b.i)

    if isLUS[1] and isHV[1] and srPS != 'None'
        label.new(b.i[1], b.h[1] * (1 + lS.default_margin * .017), '', color = srPDC, style = label.style_label_down , textcolor = color.white, size = f_getSize(srPS), tooltip = 'Rejection of Higher Prices' + vST[1] )
        alert('Rejection of higher prices detected\n' + syminfo.ticker + ' price (' + str.tostring(b.c, format.mintick) + '), timeframe ' + timeframe.period)

    if mnSH
        if b.l < lS.bx_snr_zone.get_bottom() and b.c >= lS.bx_snr_zone.get_bottom() * (1 - lS.default_margin * .17 * mnMR) and not lS.liqudation_status and b.i == lS.bx_snr_zone.get_right()
            if lS.bx_liquidity_sweeps.get_right() + srLN > b.i
                lS.bx_liquidity_sweeps.set_right(b.i + 1)
                lS.bx_liquidity_sweeps.set_bottom(math.max(math.min(b.l, lS.bx_liquidity_sweeps.get_bottom()), lS.bx_snr_zone.get_bottom() * (1 - lS.default_margin * .17 * mnMR)))
            else
                lS.bx_liquidity_sweeps.set_lefttop(b.i[1], lS.bx_snr_zone.get_bottom())
                lS.bx_liquidity_sweeps.set_rightbottom(b.i + 1, math.max(b.l, lS.bx_snr_zone.get_bottom() * (1 - lS.default_margin * .17 * mnMR)))
                lS.bx_liquidity_sweeps.set_bgcolor(mnSZC)

            lS.liqudation_status := true

        else if b.l < lS.bx_snr_zone.get_bottom() and b.c >= lS.bx_snr_zone.get_bottom() * (1 - lS.default_margin * .17 * mnMR) and lS.liqudation_status and b.i == lS.bx_snr_zone.get_right()
            lS.bx_liquidity_sweeps.set_right(b.i + 1)
            lS.bx_liquidity_sweeps.set_bottom(math.max(math.min(b.l, lS.bx_liquidity_sweeps.get_bottom()), lS.bx_snr_zone.get_bottom() * (1 - lS.default_margin * .17 * mnMR)))
        else if lS.liqudation_status and (b.c <= lS.bx_snr_zone.get_bottom() * (1 - lS.default_margin * .17 * mnMR) or b.c > lS.bx_snr_zone.get_top())
            lS.liqudation_status := false

if S.size() > 2 and srHST //and (lR.b or lS.b)// and lS.bx_snr_zone.get_bottom() != lR.bx_snr_zone.get_bottom() 
    lSt := S.get(1)

    if lS.bx_snr_zone.get_bottom() != lSt.bx_snr_zone.get_bottom()

        if  srFBO and b.c[1] < lSt.bx_snr_zone.get_bottom() * (1 - lSt.default_margin * .17) and not lSt.breakout_status //and b.i[1] != lR.bx_snr_zone.get_left()
            lSt.bx_snr_zone.set_right(b.i[1])
            lSt.ln.set_x2(b.i[1])
            lSt.breakout_status := true
            lSt.retest_status := false

            label.new(b.i[1], b.h[1] * (1 + lSt.default_margin * .017), 'B\n\n▼', color = srBDC, style = label.style_label_down , textcolor = srBTC, size = f_getSize(srBS), tooltip = 'Bearish Breakout' + vST[1] )

            R.unshift(
              SnR.new(
                 box.new(b.i[1], lSt.bx_snr_zone.get_top(), b.i + 1, lSt.bx_snr_zone.get_bottom(), border_color = color(na), bgcolor = srRZC),
                 box.new(na, na, na, na, bgcolor = color(na), border_color = color(na)),
                 line.new(b.i[1], lSt.bx_snr_zone.get_top(), b.i + 1, lSt.bx_snr_zone.get_top(), color = srRLC, width = srMR <= .5 ? 2 : 3),
                 false, false, false, false, lSt.default_margin))
            //S.remove(1)

            if srBS != 'None'
                alert('Bearish breakout detected\n' + syminfo.ticker + ' price (' + str.tostring(b.c, format.mintick) + '), timeframe ' + timeframe.period)

        else if b.c[1] < lSt.bx_snr_zone.get_bottom() and not lSt.breakout_status and not srFBO //and b.i[1] != lR.bx_snr_zone.get_left()
            lSt.bx_snr_zone.set_right(b.i[1])
            lSt.ln.set_x2(b.i[1])
            lSt.breakout_status := true
            lSt.retest_status := false

            label.new(b.i[1], b.h[1] * (1 + lSt.default_margin * .017), 'B\n\n▼', color = srBDC, style = label.style_label_down , textcolor = srBTC, size = f_getSize(srBS), tooltip = 'Bearish Breakout' + vST[1] )

            R.unshift(
              SnR.new(
                 box.new(b.i[1], lSt.bx_snr_zone.get_top(), b.i + 1, lSt.bx_snr_zone.get_bottom(), border_color = color(na), bgcolor = srRZC),
                 box.new(na, na, na, na, bgcolor = color(na), border_color = color(na)),
                 line.new(b.i[1], lSt.bx_snr_zone.get_top(), b.i + 1, lSt.bx_snr_zone.get_top(), color = srRLC, width = srMR <= .5 ? 2 : 3),
                 false, false, false, false, lSt.default_margin))
            //S.remove(1)

            if srBS != 'None'
                alert('Bearish breakout detected\n' + syminfo.ticker + ' price (' + str.tostring(b.c, format.mintick) + '), timeframe ' + timeframe.period)

        else if lRt.breakout_status and b.o[1] > lSt.bx_snr_zone.get_bottom() and b.l[1] < lSt.bx_snr_zone.get_top() and b.c[1] > lSt.bx_snr_zone.get_top() and not lSt.retest_status and b.i[1] != lSt.bx_snr_zone.get_left() //and lSt.bx_snr_zone.get_top() != lS.bx_snr_zone.get_top() //DGT
            label.new(b.i[1], b.l[1] * (1 - lSt.default_margin * .017), 'R', color = srRUC, style = label.style_label_up , textcolor = srRTC, size = f_getSize(srRS), tooltip = 'Re-test of Support Zone' + vST[1] )
            lSt.retest_status := true
            lSt.bx_snr_zone.set_right(b.i)
            lSt.ln.set_x2(b.i)

            if srRS != 'None'
                alert('Re-test of support zone detected\n' + syminfo.ticker + ' price (' + str.tostring(b.c, format.mintick) + '), timeframe ' + timeframe.period)

        else if b.l[1] < lSt.bx_snr_zone.get_top() and b.c[1] > lSt.bx_snr_zone.get_bottom() and b.c > lSt.bx_snr_zone.get_bottom() and not lSt.test_status and not lSt.breakout_status and not lRt.breakout_status and b.i[1] != lSt.bx_snr_zone.get_left()
            label.new(b.i[1], b.l[1] * (1 - lSt.default_margin * .017), 'T', color = srTUC, style = label.style_label_up , textcolor = srTTC, size = f_getSize(srTS), tooltip = 'Test of Support Zone' + vST[1] )
            lSt.test_status := true
            lSt.bx_snr_zone.set_right(b.i)
            lSt.ln.set_x2(b.i)

            if srTS != 'None'
                alert('Test of support zone detected\n' + syminfo.ticker + ' price (' + str.tostring(b.c, format.mintick) + '), timeframe ' + timeframe.period, alert.freq_once_per_bar_close)

        else if b.l < lSt.bx_snr_zone.get_top() * (1 + lSt.default_margin * .17) and not lSt.breakout_status
            if b.l < lSt.bx_snr_zone.get_top()
                lSt.bx_snr_zone.set_right(b.i)
            lSt.ln.set_x2(b.i)

        if mnSH
            if b.l < lSt.bx_snr_zone.get_bottom() and b.c >= lSt.bx_snr_zone.get_bottom() * (1 - lSt.default_margin * .17 * mnMR) and not lSt.liqudation_status and b.i == lSt.bx_snr_zone.get_right()
                if lSt.bx_liquidity_sweeps.get_right() + srLN > b.i
                    lSt.bx_liquidity_sweeps.set_right(b.i + 1)
                    lSt.bx_liquidity_sweeps.set_bottom(math.max(math.min(b.l, lSt.bx_liquidity_sweeps.get_bottom()), lSt.bx_snr_zone.get_bottom() * (1 - lSt.default_margin * .17 * mnMR)))
                else
                    lSt.bx_liquidity_sweeps.set_lefttop(b.i[1], lSt.bx_snr_zone.get_bottom())
                    lSt.bx_liquidity_sweeps.set_rightbottom(b.i + 1, math.max(b.l, lSt.bx_snr_zone.get_bottom() * (1 - lSt.default_margin * .17 * mnMR)))
                    lSt.bx_liquidity_sweeps.set_bgcolor(mnSZC)

                lSt.liqudation_status := true

            else if b.l < lSt.bx_snr_zone.get_bottom() and b.c >= lSt.bx_snr_zone.get_bottom() * (1 - lSt.default_margin * .17 * mnMR) and lSt.liqudation_status and b.i == lSt.bx_snr_zone.get_right()
                lSt.bx_liquidity_sweeps.set_right(b.i + 1)
                lSt.bx_liquidity_sweeps.set_bottom(math.max(math.min(b.l, lSt.bx_liquidity_sweeps.get_bottom()), lSt.bx_snr_zone.get_bottom() * (1 - lSt.default_margin * .17 * mnMR)))
            else if lSt.liqudation_status and (b.c <= lSt.bx_snr_zone.get_bottom() * (1 - lS.default_margin * .17 * mnMR) or b.c > lSt.bx_snr_zone.get_top())
                lSt.liqudation_status := false

//-----------------------------------------------------------------------------}
