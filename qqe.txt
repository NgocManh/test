// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © NgocManh1997

//@version=5
//strategy("No.999", overlay=true, max_lines_count=500, max_boxes_count=500, max_labels_count=500, initial_capital=10000,default_qty_type=strategy.cash, default_qty_value=200)
indicator("No.999", overlay = true, max_boxes_count = 500,  max_lines_count=500,  max_labels_count=500)

isShowBaseATR = input.bool(false)
threadhold_atr = input.float(1.0)
isCheckRange = input.bool(false)
isShowTable = input.bool(false)
isShowRibon = input.bool(true)
isShowTPSL = input.bool(false)
isShowVwap = input.bool(false)
isUseGravity = input.bool(false)
isShowBox    = input.bool(false)
length_atr = input.int(14)
mul_atr    = input.int(4)
RR = input.float(1.0)
source      = hlc3

innermult   = 1.0
outermult   = 2.415
length_db = 200
var cnt = 0
var pi          = 2 * math.asin(1)
var mult        = pi * innermult
var mult2       = pi * outermult
var gradsize    = 0.5

src_vwap = hlc3

//Interval
int = input.timeframe(defval="60", title="Interval VWAP")

//Interval Open
intopen = request.security(syminfo.tickerid, int, open)

//New Interval
newint = (intopen > intopen[1]) or (intopen < intopen[1])

//Volume
v     = volume
vsum = v
vsum  := newint ? v : vsum[1] + v

//VWAP
pv    = src_vwap*v
pvsum = pv
pvsum := newint ? pv : pvsum[1] + pv
VWAP  = pvsum/vsum

vcolor1  = VWAP > VWAP[1] ? color.lime : VWAP < VWAP[1] ? color.red : color.orange

//VWAP
plot(isShowVwap ? VWAP : na, color=vcolor1, linewidth=3, transp=0, title="VWAP")
bgcolor(newint and isShowVwap ? color.new(color.silver, 93) : na)

// }
//-----------------------
// SuperSmoother Function
// { -----------------------
supersmoother(_src, _length) =>
    s_a1    = math.exp(-math.sqrt(2) * pi / _length)
    s_b1    = 2 * s_a1 * math.cos(math.sqrt(2) * pi / _length)
    s_c3    = -math.pow(s_a1, 2)
    s_c2    = s_b1
    s_c1    = 1 - s_c2 - s_c3
    ss      = 0.0
    ss     := s_c1 * _src + s_c2 * nz(ss[1], _src[1]) + s_c3 * nz(ss[2], _src[2])


get_mrc()=>
    v_meanline    = source
    v_meanrange   = supersmoother(ta.tr, length_db)
    v_meanline    := supersmoother(source, length_db)
        
    v_upband2 = v_meanline+(v_meanrange*mult2)
    v_loband2 = v_meanline-(v_meanrange*mult2)
            
    [v_meanrange, v_upband2, v_loband2]


[meanrange, upband2, loband2]                                    = get_mrc()

float upband2_8 = upband2 + (meanrange * gradsize * -4), float loband2_8 = loband2 - (meanrange * gradsize * -4)


Length = 200

m = 0
Percent = 2
xLG = 0.0
xLG := ta.linreg(close, Length, m)
xLG3r = xLG + ((close * Percent) / 361) * 2.618
xLG3s = xLG - ((close * Percent) / 361) * 2.618    


pR = upband2_8
pS = loband2_8

if isUseGravity
    pR := math.max(upband2_8, xLG3r)
    pS := math.min(loband2_8, xLG3s)
// log.info("----")
// log.info("high: " + str.tostring(xLG3r))
// log.info("low: " + str.tostring(xLG3s))
plot(isShowRibon ? pR : na, color=color.red, title="LG3r", linewidth = 2)
plot(isShowRibon ? pS : na, color=color.green, title="LG3s", linewidth = 2)

// }
// longCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))
// if (longCondition)
//     strategy.entry("My Long Entry Id", strategy.long)

// shortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28))
// if (shortCondition)
//     strategy.entry("My Short Entry Id", strategy.short)
overbought = 70
oversold = 30
rsi_period = input(14, title='RSI length')
min_duration = input(4)
max_duration = 100

// Calculate RSI
rsi = ta.rsi(close, rsi_period)

// // Check if RSI is overbought or oversold for the specified duration
longOverbought = math.sum(rsi > overbought ? 1 : 0, max_duration) >= min_duration
longOversold = math.sum(rsi < oversold ? 1 : 0, max_duration) >= min_duration

// Generate signals
buySignal = ta.crossover(rsi, oversold) and longOversold and low <= pS // (low <= pS or high >= pR)
sellSignal = ta.crossunder(rsi, overbought) and longOverbought and high >= pR //and (high >= pR or low <= pS)

// buySignal = ta.crossover(rsi, 20) and rsi > 30 and low <= pS // (low <= pS or high >= pR)
// sellSignal = ta.crossunder(rsi, 80) and rsi < 70 and  high >= pR //and (high >= pR or low <= pS)

// Check if RSI is overbought or oversold for the specified duration


// Generate signals
// buySignal = ta.crossover(rsi, 25) and  low <= pS // (low <= pS or high >= pR)
// sellSignal = ta.crossunder(rsi, 75) and high >= pR //and (high >= pR or low <= pS)





// Plotting
plotshape(series=buySignal, title='Buy Signal', location=location.belowbar, color=color.new(color.green, 0), style=shape.labelup, text='Buy', textcolor = color.white)
plotshape(series=sellSignal, title='Sell Signal', location=location.abovebar, color=color.new(color.red, 0), style=shape.labeldown, text='Sell', textcolor = color.white)

var long_tp_boxes = array.new_box(0)
var long_sl_boxes = array.new_box(0)
var short_tp_boxes = array.new_box(0)
var short_sl_boxes = array.new_box(0)
var threshold_long_atr = array.new_line(0)
var threshold_short_atr = array.new_line(0)
// var check_used_long = array.new_int(0)
// var check_used_short = array.new_int(0)

type Tbreak      
    int idx_start 
    float price_init
    float price_tp
    float price_sl        
    float price_active_trailing_sl
    float price_sl_trailing
    float base_atr
    int cur_level_atr    
    int doing
    

// method update(Tbreak br,int idx_start_,float price_init_,float price_tp_,float price_sl_,int cur_level_atr_,int done_) => br.idx_start := idx_start_, br.price_init := price_init_, br.price_tp := price_tp_, br.price_sl := price_sl_, br.cur_level_atr := cur_level_atr_, br.doing := done_

var arr_box_long = array.new<Tbreak>(0)
var arr_box_short = array.new<Tbreak>(0)

cTP            = #21f321
cSL            = #ff5d00
atr = ta.atr(length_atr)

length_lsma = input.int(50)
lsma = ta.linreg(close, length_lsma, 0)

check_range_long = isCheckRange ? (ta.barssince(buySignal == true)[1] > 10) : true
check_range_short =isCheckRange ? (ta.barssince(sellSignal == true)[1] > 10) : true

count_barsince_rise() =>
    res = 0
    for i = 0 to 100
        if lsma[i] > lsma[i+1]
            res := i
        else
            break

    res

count_barsince_fall() =>
    res = 0
    for i = 0 to 100
        if lsma[i] < lsma[i+1]
            res := i
        else
            break

    res


lsma_barsince_rise  = ta.barssince(lsma > lsma[1])
lsma_barsince_fall  = ta.barssince(lsma < lsma[1])
// lsma_barsince_rise  = count_barsince_fall()
// lsma_barsince_fall  = count_barsince_rise()

if (buySignal and check_range_long and isShowBox)
    
    //label.new(bar_index, high, text = str.tostring(lsma_barsince_rise), textcolor = color.white)
    tp = close + atr * mul_atr * RR
    sl = close - atr * mul_atr
    price_active_trailing_sl = close + atr * 2
    n = bar_index
    box bTp = box.new(n, tp, n+3, close, bgcolor = color.new(cTP, 85))
    box bSl = box.new(n, close, n+3, sl, bgcolor = color.new(cSL, 85))    
    line tmp = line.new(bar_index, close - atr * threadhold_atr, bar_index+3, close - atr * threadhold_atr, color = color.white, width = 1)

    // box.set_text(tmp, "FVG")
    // box.set_text_color(tmp,  color.white)
    // box.set_text_size(tmp, size.tiny)
    array.unshift(long_tp_boxes, bTp)
    array.unshift(long_sl_boxes, bSl)
    Tbreak obj = Tbreak.new(bar_index, close, tp, sl, price_active_trailing_sl, sl, atr, 1, 1)
    array.unshift(arr_box_long, obj)
    array.unshift(threshold_long_atr, tmp)

    
else if (sellSignal and check_range_short and isShowBox)
    //label.new(bar_index, high, text = str.tostring(lsma_barsince_fall), textcolor = color.white)
    //label.new(bar_index, high, text = str.tostring(check_range_short), textcolor = color.white)
    tp = close - atr * mul_atr *  RR
    sl = close + atr * mul_atr
    price_active_trailing_sl = close - atr * 2
    n = bar_index
    box bTp = box.new(n, close, n+3, tp, bgcolor = color.new(cTP, 85))
    box bSl = box.new(n, sl, n+3, close, bgcolor = color.new(cSL, 85))    
    // box.set_text(tmp, "FVG")
    // box.set_text_color(tmp,  color.white)
    // box.set_text_size(tmp, size.tiny)
    line tmp = line.new(bar_index, close + atr * threadhold_atr, bar_index+3, close + atr * threadhold_atr, color = color.white, width = 1)
    array.unshift(short_tp_boxes, bTp)
    array.unshift(short_sl_boxes, bSl)
    Tbreak obj = Tbreak.new(bar_index, close, tp, sl, price_active_trailing_sl, sl, atr, 1, 1)
    array.unshift(arr_box_short, obj)    
    array.unshift(threshold_short_atr, tmp)


size_box_long = array.size(arr_box_long)
size_box_short = array.size(arr_box_short)

var res_tp = 0.0
var res_sl = 0.0
var cnt_long = 0
var cnt_short = 0
var cnt_long_tp = 0
var cnt_short_tp = 0
if size_box_long > 0
    for j = 0 to size_box_long - 1        
        Tbreak tbox = array.get(arr_box_long, j)
        check_used = tbox.doing
        if check_used != 0
            box tp = array.get(long_tp_boxes, j)                        
            box sl = array.get(long_sl_boxes, j)    
            line tmp = array.get(threshold_long_atr, j)
            price_tp = tbox.price_tp
            price_sl_trailing = tbox.price_sl_trailing
            price_init = tbox.price_init
            curIdx_init = tbox.idx_start
            
            if curIdx_init != bar_index and price_sl_trailing >= low     // STOP LOSS                       
                tbox.doing := 0
                res = ((price_sl_trailing-price_init)/price_init)*100
                if res < 0.0
                    res_sl := res_sl + res
                else if res > 0.0
                    res_tp := res_tp + res

                //res_sl := res_sl + res
                if isShowTPSL
                    label.new(int((box.get_left(sl) + bar_index) / 2), price_sl_trailing, text = str.format("{0}%", res), textcolor = color.white)
                
            else if curIdx_init != bar_index and close[1] < tbox.price_active_trailing_sl and close >= tbox.price_active_trailing_sl//and price_tp <= high
                tbox.price_sl_trailing := tbox.price_active_trailing_sl - tbox.base_atr
                tbox.price_active_trailing_sl := tbox.price_active_trailing_sl + tbox.base_atr                            
            
            box.set_right(tp, bar_index)
            box.set_right(sl, bar_index)
            if tbox.price_tp < price_sl_trailing
                box.set_top(tp, price_sl_trailing)
            line.set_x2(tmp, bar_index)

if size_box_short > 0
    for j = 0 to size_box_short - 1        
        Tbreak tbox = array.get(arr_box_short, j)
        check_used = tbox.doing
        if check_used != 0
            box tp = array.get(short_tp_boxes, j)                        
            box sl = array.get(short_sl_boxes, j)    
            line tmp = array.get(threshold_short_atr, j)
            price_tp = tbox.price_tp
            price_sl = tbox.price_sl
            price_init = tbox.price_init
            curIdx_init = tbox.idx_start
            price_sl_trailing = tbox.price_sl_trailing
            if curIdx_init != bar_index and price_sl_trailing <= high   // STOP LOSS
                res = ((price_init-price_sl_trailing)/price_init)*100     
                if res < 0.0
                    res_sl := res_sl + res
                else if res > 0.0
                    res_tp := res_tp + res           
                //res_sl := res_sl + res
                if isShowTPSL
                    label.new(int((box.get_left(sl) + bar_index) / 2), price_sl_trailing, text = str.format("{0}%", res), textcolor = color.white)
                tbox.doing := 0
            else if curIdx_init != bar_index and close[1] > tbox.price_active_trailing_sl and close <= tbox.price_active_trailing_sl//price_tp >= low // TAKE PROFIT
                tbox.price_sl_trailing := tbox.price_active_trailing_sl + tbox.base_atr
                tbox.price_active_trailing_sl := tbox.price_active_trailing_sl - tbox.base_atr                            
            
            box.set_right(tp, bar_index)
            box.set_right(sl, bar_index)
            line.set_x2(tmp, bar_index)

            if tbox.price_tp > price_sl_trailing
                box.set_bottom(tp, price_sl_trailing)



// if barstate.islastconfirmedhistory and isShowTable    
//     tbl = table.new(position.bottom_center, 3, 4  , bgcolor      = #1e222d
//   , border_color = #373a46
//   , border_width = 1
//   , frame_color  = #373a46
//   , frame_width  = 1)  // 3 cột và 1 hàng

//     table.cell(tbl, 0, 0, "TP", text_color = color.white)
//     table.cell(tbl, 1, 0, "SL", text_color = color.white)
//     table.cell(tbl, 2, 0, "Profit", text_color = color.white)
//     table.cell(tbl, 0, 2, "Long signal", text_color = color.white)
//     table.cell(tbl, 1, 2, "Short signal", text_color = color.white)
//     table.cell(tbl, 2, 2, "%Win", text_color = color.white)
    
//     cnt_win = cnt_short_tp + cnt_long_tp
//     cnt_tt  = size_box_long + size_box_short

//     table.cell(tbl, 0, 1, str.format("{0}%", res_tp), text_color = color.white)
//     table.cell(tbl, 1, 1, str.format("{0}%",res_sl), text_color = color.white)
//     table.cell(tbl, 2, 1, str.format("{0}%",res_tp - res_sl),text_color = color.white)
//     table.cell(tbl, 0, 3, str.format("{0}/{1}",cnt_long_tp, size_box_long), text_color = color.white)
//     table.cell(tbl, 1, 3, str.format("{0}/{1}",cnt_short_tp, size_box_short),text_color = color.white)
//     table.cell(tbl, 2, 3, str.format("{0}/{1} -> {2}%", cnt_win, cnt_tt, (cnt_win/cnt_tt)*100),text_color = color.white)


if barstate.islastconfirmedhistory
    label.new(bar_index, high, text = str.format("TP: {0} SL: {1} -> profit: {2}%", res_tp, res_sl, res_tp+res_sl), textcolor = color.white)
