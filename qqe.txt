// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// © LuxAlgo

//@version=5
indicator("Range Detector [LuxAlgo]", "LuxAlgo - Range Detector", overlay = true, max_boxes_count = 500, max_lines_count = 500)
//------------------------------------------------------------------------------
//Settings
//-----------------------------------------------------------------------------{
length = input.int(20, 'Minimum Range Length', minval = 2)
mult   = input.float(1., 'Range Width', minval = 0, step = 0.1)
atrLen = input.int(500, 'ATR Length', minval = 1)

//Style
upCss = input(#089981, 'Broken Upward', group = 'Style')
dnCss = input(#f23645, 'Broken Downward', group = 'Style')
unbrokenCss = input(#2157f3, 'Unbroken', group = 'Style')

//-----------------------------------------------------------------------------}
//Detect and highlight ranges
//-----------------------------------------------------------------------------{
//Ranges drawings
var box bx = na
var line lvl = na

//Extensions
var float max = na
var float min = na

var os = 0
color detect_css = na

n = bar_index
atr = ta.atr(atrLen) * mult
ma = ta.sma(close, length)

count = 0
for i = 0 to length-1
    count += math.abs(close[i] - ma) > atr ? 1 : 0

if count == 0 and count[1] != count
    //Test for overlap and change coordinates
    if n[length] <= bx.get_right()
        max := math.max(ma + atr, bx.get_top())
        min := math.min(ma - atr, bx.get_bottom())
        
        //Box new coordinates
        bx.set_top(max)
        bx.set_rightbottom(n, min)
        bx.set_bgcolor(color.new(unbrokenCss, 80))

        //Line new coordinates
        avg = math.avg(max, min)
        lvl.set_y1(avg)
        lvl.set_xy2(n, avg)
        lvl.set_color(unbrokenCss)
    else
        max := ma + atr
        min := ma - atr

        //Set new box and level
        bx := box.new(n[length], ma + atr, n, ma - atr, na
          , bgcolor = color.new(unbrokenCss, 80))
        
        lvl := line.new(n[length], ma, n, ma
          , color = unbrokenCss
          , style = line.style_dotted)

        detect_css := color.new(color.gray, 80)
        os := 0

else if count == 0
    bx.set_right(n)
    lvl.set_x2(n)

//Set color
if close > bx.get_top()
    bx.set_bgcolor(color.new(upCss, 80))
    lvl.set_color(upCss)
    os := 1
else if close < bx.get_bottom()
    bx.set_bgcolor(color.new(dnCss, 80))
    lvl.set_color(dnCss)
    os := -1

//-----------------------------------------------------------------------------}
//Plots
//-----------------------------------------------------------------------------{
//Range detection bgcolor
bgcolor(detect_css)

plot(max, 'Range Top'
  , max != max[1] ? na : os == 0 ? unbrokenCss : os == 1 ? upCss : dnCss)

plot(min, 'Range Bottom'
  , min != min[1] ? na : os == 0 ? unbrokenCss : os == 1 ? upCss : dnCss)

//-----------------------------------------------------------------------------}



345234-----------------
// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// © LuxAlgo

//@version=5
indicator("Hull Butterfly Oscillator [LuxAlgo]", "Hull Butterfly Oscillator [LuxAlgo]")
//-----------------------------------------------------------------------------}
//Settings
//----------------------------------------------------a-------------------------{
length = input(14)

mult = input(2., 'Levels Multiplier')

src = input(close)

//Style
bull_css_0 = input.color(color.new(#0cb51a, 50), 'Bullish Gradient'
  , inline = 'inline0'
  , group = 'Style')

bull_css_1 = input.color(#0cb51a, ''
  , inline = 'inline0'
  , group = 'Style')

bear_css_0 = input.color(color.new(#ff1100, 50), 'Bearish Gradient'
  , inline = 'inline1'
  , group = 'Style')

bear_css_1 = input.color(#ff1100, ''
  , inline = 'inline1'
  , group = 'Style')

//-----------------------------------------------------------------------------}
//Normalization variables
//-----------------------------------------------------------------------------{
var short_len = int(length / 2)
var hull_len = int(math.sqrt(length))

var den1 = short_len * (short_len + 1) / 2
var den2 = length * (length + 1) / 2
var den3 = hull_len * (hull_len + 1) / 2

//-----------------------------------------------------------------------------}
//Hull coefficients
//-----------------------------------------------------------------------------{
var lcwa_coeffs = array.new_float(hull_len, 0)
var hull_coeffs = array.new_float(0)

if barstate.isfirst
    //Linearly combined WMA coeffs
    for i = 0 to length-1
        sum1 = math.max(short_len - i, 0)
        sum2 = length - i
    
        array.unshift(lcwa_coeffs, 2 * (sum1 / den1) - (sum2 / den2))
    
    //Zero padding of linearly combined WMA coeffs
    for i = 0 to hull_len-2
        array.unshift(lcwa_coeffs, 0)
    
    //WMA convolution of linearly combined WMA coeffs
    for i = hull_len to array.size(lcwa_coeffs)-1
        sum3 = 0.
        for j = i-hull_len to i-1
            sum3 += array.get(lcwa_coeffs, j) * (i - j)
        
        array.unshift(hull_coeffs, sum3 / den3)

//-----------------------------------------------------------------------------}
//Hull squeeze oscillator
//-----------------------------------------------------------------------------{
var os  = 0
var len = array.size(hull_coeffs)-1
hma     = 0.
inv_hma = 0.

for i = 0 to len
    hma += src[i] * array.get(hull_coeffs, i)
    inv_hma += src[len-i] * array.get(hull_coeffs, i)
    
hso = hma - inv_hma

cmean = ta.cum(math.abs(hso)) / bar_index * mult

os := ta.cross(hso, cmean) or ta.cross(hso, -cmean) ? 0
  : hso < hso[1] and hso > cmean ? -1
  : hso > hso[1] and hso < -cmean ? 1
  : os

//-----------------------------------------------------------------------------}
//Plot
//-----------------------------------------------------------------------------{
//Colors
css0 = color.from_gradient(hso, 0, cmean, bull_css_0, bull_css_1)
css1 = color.from_gradient(hso, -cmean, 0, bear_css_1, bear_css_0)
css = hso > 0 ? css0 : css1

//Oscillator line/histogram
plot(hso, 'Hull Butterfly', css
  , style = plot.style_histogram)

plot(hso, 'Hull Butterfly', chart.fg_color)

//Dots
plot(os > os[1] and os == 1 ? hso : na, 'Bullish Dot'
  , bull_css_1
  , 2
  , plot.style_circles)
  
plot(os < os[1] and os == -1 ? hso : na, 'Bearish Dot'
  , bear_css_1
  , 2
  , plot.style_circles)


//Levels
plot(cmean, color = color.gray, editable = false)

plot(cmean / 2, color = color.gray, editable = false)

plot(-cmean / 2, color = color.gray, editable = false)

plot(-cmean, color = color.gray, editable = false)

//-----------------------------------------------------------------------------}
